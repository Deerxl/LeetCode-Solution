# 知识整理

## 集合框架

### 1. HashMap

* [HashMap详解](https://zhuanlan.zhihu.com/p/21673805)

* 从结构实现来讲，HashMap 是**数组+链表+红黑树**（JDK1.8增加了红黑树部分）实现的，如下如所示。 

* ![HashMap 存储字段](https://pic1.zhimg.com/8db4a3bdfb238da1a1c4431d2b6e075c_r.jpg)

#### - HashMap 的长度为什么是2的幂次方？

为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，每个链表/红黑树长度大致相同。这个实现就是把数据存到哪个链表/红黑树中的算法。

**这个算法应该如何设计呢？**

我们首先可能会想到采用%取余的操作来实现。但是，重点来了：**“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&)操作（也就是说 hash%length==hash&(length-1)的前提是 length 是2的 n 次方；）。”** 并且 **采用二进制位操作 &，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。**

### 2. HashTable 和 HashMap 的区别

1. **线程是否安全：** HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过  `synchronized`  修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；

2. **效率：** 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；

3. **对Null key 和 Null value的支持：** HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛NullPointerException。

4. **初始容量大小和每次扩充容量大小的不同 ：**   ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小。也就是说 HashMap 总是使用2的幂作为哈希表的大小,后面会介绍到为什么是2的幂次方。

5. **底层数据结构：** JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。
6. ![继承关系](https://pic2.zhimg.com/26341ef9fe5caf66ba0b7c40bba264a5_r.jpg)

### 3.  HashMap 和 HashSet 的区别

![区别](https://user-gold-cdn.xitu.io/2018/3/2/161e717d734f3b23?imageslim)

### 4. Arraylist 与 LinkedList 异同

1. **是否保证线程安全：** ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；

2. **底层数据结构：** Arraylist 底层使用的是Object数组；LinkedList 底层使用的是双向循环链表数据结构；

3. **插入和删除是否受元素位置的影响：** ① **ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。** 比如：执行`add(E e)`方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（`add(int index, E element)`）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② **LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是近似 O（1）而数组为近似 O（n）。**

4. **是否支持快速随机访问：** LinkedList 不支持高效的随机元素访问，而ArrayList 实现了RandmoAccess 接口，所以有随机访问功能。快速随机访问就是通过元素的序号快速获取元素对象(对应于`get(int index)`方法)。

5. **内存空间占用：** ArrayList 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。

### 5. ArrayList 与 Vector 区别

Vector 类的所有方法都是同步的。可以由两个线程安全地访问一个 Vector 对象、但是一个线程访问 Vector 的话代码要在同步操作上耗费大量的时间。

Arraylist 不是同步的，所以在不需要保证线程安全时时建议使用Arraylist。

### 6. ConcurrentHashMap 和 Hashtable 的区别

ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。

- **底层数据结构：** JDK1.7的 ConcurrentHashMap 底层采用 **分段的数组+链表** 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 **数组+链表** 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；

- **实现线程安全的方式（重要）：** ① **在JDK1.7的时候，ConcurrentHashMap（分段锁）** 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比Hashtable效率提高16倍。） **到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化）**  整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② **Hashtable(同一把锁)** :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。

- 两者的对比图：

  HashTable:
  ![HashTable](https://user-gold-cdn.xitu.io/2018/8/23/1656677a6f256196?imageslim)

  JDK 1.7 ConcurrentHashMap
  ![JDK 1.7 CurrentHashMap](https://user-gold-cdn.xitu.io/2018/8/23/1656677a6f008be4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
  
  jdk 1.8 ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）
  ![JDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）](https://user-gold-cdn.xitu.io/2018/8/23/1656677a6f14e039?imageslim)

## 操作系统

### Linux命令

#### 安全：umask

* 用来设置限制新建文件权限的掩码。当新文件被创建时，其最初的权限由文件创建掩码决定。用户每次注册进入系统时，umask命令都被执行， 并自动设置掩码mode来限制新文件的权限。用户可以通过再次执行umask命令来改变默认值，新的权限将会把旧的覆盖掉。 

* 操作符“=”在umask命令和[chmod](http://man.linuxde.net/chmod)命令中的作用恰恰相反。在chmod命令中，利用它来设置指定的权限，而其余权限则被删除；但是在umask命令中，它将在原有权限的基础上删除指定的权限。 

#### 进程控制：pid fork 

* fork调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次。 

* 它可能有三种不同的**返回值**：
  1. 在父进程中，fork返回新创建子进程的进程ID;
  2. 在子进程中，fork返回0;
  3. 如果出现错误，fork返回一个负值； 

* fork**出错**可能有两种原因：
  1. 当前的进程数已经达到了系统规定的上限，这时errno的值被设置为EAGAIN。
  2. 系统内存不足，这时errno的值被设置为ENOMEM。 

```c
#include <unistd.h>
#include <stdio.h> 
int main () 
{ 
	pid_t fpid; //fpid表示fork函数返回的值
	fpid=fork(); 
	if (fpid < 0) 
		printf("error in fork!"); 
	else if (fpid == 0) {	//子进程
		printf("i am the child process, my process id is %d/n",getpid()); 	//getpid()获取pid的值
	}
	else {		//父进程
		printf("i am the parent process, my process id is %d/n",getpid()); 
	}
	return 0;
}
```

#### 管道pipe

* 特质：
  1. 其本质是一个伪文件(实为内核缓冲区)
  2. 由两个文件描述符引用，一个表示读端，一个表示写端。
  3. 规定数据从管道的**写端流入**管道，从**读端流出**。

* 管道的原理: 管道实为内核使用环形队列机制，借助内核缓冲区(4k)实现。
* 管道的局限性：
  1. 数据自己读不能自己写。
  2. 数据一旦被读走，便不在管道中存在，不可反复读取。
  3. 由于管道采用**半双工通信**方式。因此，数据只能在一个方向上流动。
  4. 只能在有公共祖先的进程间使用管道。

```c
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>
 
int main(void)
{
	int pipe(int pipefd[2]); //创建管道，成功：0；失败：-1，设置errno
	pid_t pid = fork();
 
	if (pid == 0) {  //child
		close(fd[1]);	                //子进程从管道中读数据，关闭写端
		dup2(fd[0], STDIN_FILENO);		//让wc从管道中读取数据
		execlp("wc", "wc", "-l", NULL);	//wc命令默认从标准读入取数据
	} else {
		close(fd[0]);	//父进程向管道中写数据，关闭读端
		dup2(fd[1], STDOUT_FILENO);		//将ls的结果写入管道中
		execlp("ls", "ls", NULL);		//ls输出结果默认对应屏幕
	}
	return 0;
}
```

#### 进程通信：共享内存函数shmget

* 得到一个共享内存标识符或创建一个共享内存对象并返回共享内存标识符。

*  int shmget(key_t key, size_t size, int shmflg)  成功：返回共享内存的标识符； 出错：-1，错误原因存于error中。

####  进程通信：内存映射函数 mmap()

* 内存映射，简而言之就是将**用户空间的一段内存区域映射到内核空间**，映射成功后，用户对这段内存区域的修改可以直接反映到内核空间，同样，内核空间对这段区域的修改也直接反映用户空间。那么对于内核空间<---->用户空间两者之间需要大量数据传输等操作的话效率是非常高的。
* mmap函数是unix/linux下的系统调用，详细内容可参考《Unix Netword programming》卷二12.2节。
  mmap系统调用并不是完全为了用于共享内存而设计的。它本身提供了不同于一般对普通文件的访问方式，**进程可以像读写内存一样对普通文件的操作**。而Posix或系统V的共享内存IPC则纯粹用于共享目的，当然mmap()实现共享内存也是其主要应用之一。
* mmap系统调用使得进程之间通过映射同一个普通文件实现共享内存。普通文件被映射到进程地址空间后，进程可以像访问普通内存一样对文件进行访问，不必再调用read()，write()等操作。mmap并不分配空间, 只是将文件映射到调用进程的地址空间里（但是会占掉你的 virutal memory）, 然后你就可以用memcpy等操作写文件, 而不用write()了.写完后，内存中的内容并不会立即更新到文件中，而是有一段时间的延迟，你可以调用msync()来显式同步一下, 这样你所写的内容就能立即保存到文件里了.这点应该和驱动相关。 不过通过mmap来写文件这种方式没办法增加文件的长度, 因为要映射的长度在调用mmap()的时候就决定了.如果想取消内存映射，可以调用munmap()来取消内存映射

####  安全：chown()

* Linux/Unix 是多人多工操作系统，所有的文件皆有拥有者。利用 chown **将指定文件的拥有者改为指定的用户或组**，用户可以是用户名或者用户ID；组可以是组名或者组ID；文件是以空格分开的要改变权限的文件列表，支持通配符。
* 一般来说，这个指令只有是由系统管理者(root)所使用，一般使用者没有权限可以改变别人的文件拥有者，也没有权限把自己的文件拥有者改设为别人。只有系统管理者(root)才有这样的权限。

 #### 设备操作：ioctl

 ioctl 是设备驱动程序中设备控制接口函数，一个字符设备驱动通常会实现设备打开、关闭、读、写等功能，在一些需要细分的情境下，如果需要扩展新的功能，通常以增设 ioctl() 命令的方式实现。 

## Java

### == 和 equals

* **==** : 它的作用是判断两个**对象的地址**是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)

* **equals()** : 它的作用也是判断**两个对象**是否相等。但它一般有两种使用情况：

  情况 1：类没有覆盖 equals()方法。则通过 equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。

  情况 2：类覆盖了 equals()方法。一般，我们都覆盖 equals()方法来两个对象的内容相等；若它们的内容相等，则返回 true(即，认为这两个对象相等)。

### hashCode 与 equals

## 计网

